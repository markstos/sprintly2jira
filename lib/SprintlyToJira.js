"use strict"
const _ = require('lodash')
const j2m = require('jira2md')
const rp = require('request-promise')
const Promise = require('bluebird');
const stringify = Promise.promisify(require('csv-stringify'));
const fs = require('fs');

var sprintlyAgent = rp.defaults({
   baseUrl: 'https://sprint.ly/api/products',
   auth: {
     // Your Sprint.ly API key is found here: https://sprint.ly/account/settings/profile
     'user': process.env.SPRINTLY_EMAIL,
     'pass': process.env.SPRINTLY_API_KEY
   },
   headers: {
       'User-Agent': 'Request-Promise',
       'Accept': 'application/json',
       'Content': 'application/json',
   },
   json: true, // Automatically parses the JSON string in the response
   //simple: true,
})

class SprintlyToJira {
    constructor(options) {
      this.sprintlyProjectNum = options.sprintlyProjectNum
      this.jiraProjectKey = options.jiraProjectKey
      this.userMap = options.userMap;
      this.projectMap = options.projectMap
      this.jiraBaseUrl = options.jiraBaseUrl // no trailing slash
      this.fileProxyBaseUrl = options.fileProxyBaseUrl
      // TODO: Add input validation

      // a mapping of Sprint.ly item #s to parent item #s,
      // generated by extractItemParentIds
      this.ticketParentMap = _.defaultTo(options.ticketParentMap, {})

      // In the JIRA CSV format, we have to have one column per tag, comment, and attachment.
      // We allocate a number of columns for each that is expected to exceed the maximum amount
      // used.
      this.maxLabels      = _.defaultTo(options.maxLabels,20);
      this.maxComments    = _.defaultTo(options.maxComments,500);
      this.maxAttachments = _.defaultTo(options.maxAttachments,40);

      // Returns a format like 2018-01-02-18-47
      const thisMinute = (new Date().toISOString().slice(0, 16)).replace(/[T:]/g,'-');

      // Default to timestamping files as a form of backup.
      this.csvFileName = _.defaultTo(options.csvFileName,`./sprintly-export-${this.jiraProjectKey}-${thisMinute}.csv`)

      // Keep track of the number items that have been arrayified
      // So we know which row is at fault if there'sa problem;
      this.numItemsArrayified = 0;

    }

  // To support paging, we need to know the newest ticket number
  // (Or I guess we could always stop paging when get back less than 500 results!)
  async getNewestTicketNumber () {
    const newestItem = await sprintlyAgent.get(
      `/${this.sprintlyProjectNum}/items.json?order_by=newest&limit=1`);
    return newestItem[0].number;
  }

  // For paging, get the offsets of the ticket numbers, starting at zero, incrementing by 500
  // and stopping at the newest ticket number.
  async getTicketOffsets () {
    const newestTicketNum = await this.getNewestTicketNumber();
    let offsets = []
    for (var i = 0; i <= newestTicketNum; i = i+250) {
      offsets.push(i);
    }
    return offsets;
    //return [0,1,2,3,4,5,6,7,8,9,10,11];
  }

  async extractAllItems () {
    let completedGets = 0;
    let foundItems = 0;
    const offsets = await this.getTicketOffsets()
    const allPages = await Promise.map(offsets, async offset => {
      const qs = "children=1&order_by=oldest&status=someday,backlog,in-progress,completed,accepted&limit=250&offset="+offset;
      const items = await sprintlyAgent.get(`/${this.sprintlyProjectNum}/items.json?${qs}`)

      completedGets++;
      foundItems += items.length;
      console.log(`    Completed %s/%s calls. Found %s items so far.`,
                  completedGets, offsets.length, foundItems);
      return items
    },
    { concurrency: 8 })
    return _.compact(_.flatten(allPages));
  }

  /*
  Create mapping of tickets to parent tickets.

  To make item processing easier later, we generate and cache a mapping of issues to parent issues,
  which is how JIRA will connect parent and child meetings.

  Steps:
   1. Call items.json API to select all items of type=story, which would get their IDs
        (There are about 73, so we don't have to worry about paging).
   2. For each story, we call children.json and get the child IDs.
   3. As we go, we build a data structure that maps child IDs to parent IDS,
      saving into this.ticketParentMap and returning it.
  */
  async extractItemParentIds () {
    const items = await sprintlyAgent.get(
      `/${this.sprintlyProjectNum}/items.json?type=story&order_by=oldest`);

    const itemNums = _.map(items,'number');
      await Promise.map(itemNums, async itemNum => {
        const children = await sprintlyAgent.get(
          `/${this.sprintlyProjectNum}/items/${itemNum}/children.json`)
        const childNums = _.map(children,'number');
        childNums.map(childNum => {
          this.ticketParentMap[childNum] = itemNum;
        })
      },
      { concurrency: 10 }) // Adjust to tune performance

    return  this.ticketParentMap
}

  // Pull one item from Sprint.ly, un-modified
  extractItem (itemNum) {
    return sprintlyAgent.get(
      `/${this.sprintlyProjectNum}/items/${itemNum}.json`)
  }

  // Pull one items comments from Sprint.ly, un-modified
  // https://support.sprint.ly/hc/en-us/articles/213152618-Comment://support.sprint.ly/hc/en-us/articles/213152618-Comments
  extractItemComments (itemNum) {
       return _.defaultTo(sprintlyAgent.get(
         `/${this.sprintlyProjectNum}/items/${itemNum}/comments.json`),[]);
  }

  // Convert Sprint.ly comment array into JIRA CSV comment array
  transformItemComments (comments) {
    return _.map(comments,this.transformItemComment.bind(this));
  }

  // Convert a single Sprint.ly comment into a JIRA csv comment;
  transformItemComment (comment) {
    // Comment creation times are lost in Sprint.ly export, so pick arbitrary time.
    const date = '2018-07-01T00:00:00+00:00'
    const userName = this.userMap[comment.created_by.email]
    const body = this.transformMarkdown(comment.body)
    return `${date}; ${userName}; ${body}`
  }

  validateItemComments (comments) {
    if (comments.length > this.maxComments) {
      throw Error(`Found item with ${comments.length} comments, but ${this.maxComments} is max`)
    }
  }

  validateItemAttachments (attachments) {
    if (attachments.length > this.maxAttachments) {
      throw Error(`Found item with ${attachments.length} comments, but ${this.maxAttachments} is max`)
    }
  }

  validateItemLabels (labels) {
    labels = _.defaultTo(labels,[]);
    if (labels.length > this.maxlabels) {
      throw Error(`Found item with ${labels.length} comments, but ${this.maxlabels} is max`)
    }
  }


  // Given a sprintly item object, modify by reference to add a "comments" array
  // of JIRA style comments;
  async addItemComments(item) {
    const sprintlyComments = await this.extractItemComments(item.number);
    this.validateItemComments(sprintlyComments); // throw if fails
    item.comments = this.transformItemComments(_.defaultTo(sprintlyComments,[]))
  }


  // Pull one items attachments from Sprint.ly, un-modified
  extractItemAttachments (itemNum) {
       return _.defaultTo(sprintlyAgent.get(
         `/${this.sprintlyProjectNum}/items/${itemNum}/attachments.json`),[]);
  }


  get sprintlyItemRE () {
    return new RegExp('https://sprint\.ly/product/(\\d+)/item/(\\d+)','g')
  }

   get sprintlyFileRE () {
    return new RegExp('https://sprint\.ly/product/(\\d+)/file/(\\d+)','g')
  }


  // Convert a single Sprint.ly comment into a JIRA csv comment;
  async transformItemAttachment (attachment) {
    const proxyUrl = attachment.href.replace(this.sprintlyFileRE, (match, projectNum, itemNum) => {
      return this.fileProxyBaseUrl+'/product/'+projectNum+'/file/'+itemNum
   })
   return await rp({
     uri: proxyUrl,
     followRedirect: false,
     simple: false,
     resolveWithFullResponse: true,
   })
   .then(res => res.headers.location)
  }

  // Convert Sprint.ly comment array into JIRA CSV comment array
  async transformItemAttachments (comments) {
    return await Promise.map(comments,this.transformItemAttachment.bind(this));
  }

  // Given a Sprintly item object, modify by reference to add "attachments" array
  // of attachment URLs
  async addItemAttachments (item) {
    const attachments = await this.extractItemAttachments(item.number);
    this.validateItemAttachments(attachments); // throw if fails
    item.attachments = await this.transformItemAttachments(_.defaultTo(attachments,[]))
  }

  // Given an array of Sprint.ly items, add "comments" for all items.
  async addCommentsToAllItems (items) {
    return Promise.map(items, this.addItemComments.bind(this), { concurrency: 8 });
  }

  // Given array of Sprint.ly items, add "attachments" array.
  async addAttachmentsToAllItems (items) {
    return Promise.map(items, this.addItemAttachments.bind(this), { concurrency: 8 });
  }

/*
Translate Sprint.ly Markdown to JIRA format.

Also:

 * replace links to Sprint.ly tickets to corresponding JIRA issues.
 * Replace #123 refs with Links to current project issue.

Used for both item bodies as well as comment bodies.
*/
 transformMarkdown (sprintlyDesc) {
   var jiraDesc = j2m.to_jira(sprintlyDesc);

   // Replace links to Sprint.ly tickets with corresponding JIRA tickets
   jiraDesc = jiraDesc.replace(this.sprintlyItemRE, (match, projectNum, itemNum) => {
     return this.jiraBaseUrl+'/browse/'+this.projectMap[projectNum]+'-'+itemNum
   })

   // Replace "#123" with a link if it hasn't already been replaced.
   return jiraDesc.replace(/#(\d\d+)(?![|\d])/g, (match, itemNum) => {
     return `[${match}|${this.jiraBaseUrl}/browse/${this.jiraProjectKey}-${itemNum}]`
   })
 }

 validateSprintlyItem (sprintlyItem) {
   if (_.isUndefined(this.userMap[sprintlyItem.created_by.email])) {
     throw Error("For sprint.ly item # "+sprintlyItem.number
      +" found unknown created_by email: "+ sprintlyItem.created_by.email
      +"\nAdd correct mapping to your userMap")
   }

   this.validateItemLabels(sprintlyItem.labels);
 }

get issueTypeMap () {
  return {
    'task': 'Task',
    'defect': 'Bug',
    'story': 'Story',
    'test': 'Task',
  }
}

getJiraIssueType (sprintlyType, itemNumber) {

  // If it has a parent, Issue Type needs needs to be "Sub-Task"
  // Yes, this is lossy. Sprint.ly allowed other types as sub-tasks.
  if (this.ticketParentMap[itemNumber]) {
    return 'Sub-Task'
  }
  else {
    return  this.issueTypeMap[sprintlyType];
  }
}

  //map the sprintly item's fields to Jira issue fields
  // For example structure of sprintlyItem, see: https://support.sprint.ly/hc/en-us/articles/213642287-Items
  transformItem (sprintlyItem) {
    this.validateSprintlyItem(sprintlyItem);

    var jiraIssue = {
          // "project": { "key": this.jiraProjectKey, }, // Specified during CSV upload.
          "Issue Key": `${this.jiraProjectKey}-${sprintlyItem.number}`,

          // JIRA doesn't keep the Issue Id and Parent ID, but uses them to identify
          // and connect parent/child ticket relationships
          "Issue Id": sprintlyItem.number,
          "Parent Id": this.ticketParentMap[sprintlyItem.number],

          "Summary": sprintlyItem.title,
          "Issue Type":  this.getJiraIssueType(sprintlyItem.type, sprintlyItem.number),
          // map using email as name value varies from JIRA account to Sprintly
          // Tickets may be assigned to no-one, which we treat as "null" here.
          "Assignee": this.userMap[_.get(sprintlyItem,'assigned_to.email',null)],
          "Reporter": this.userMap[sprintlyItem.created_by.email],
          "Description": this.transformMarkdown(sprintlyItem.description),
          "Status" : sprintlyItem.status,
          "Date Created": sprintlyItem.created_at,
          "Date Modified": sprintlyItem.last_modified,
          "labels": _.defaultTo(sprintlyItem.tags, []), // An array to translate to one per column.!

          // pass these through
          "comments": sprintlyItem.comments,
          "attachments": sprintlyItem.attachments,

          // "comments": commentItem.body,
    };

    if (jiraIssue["Status"] === 'accepted') {
      jiraIssue["Resolution"] = "Done"
    }

    return jiraIssue;
  }

  // Return the CSV Header row as an array
  // It's padded with columns for the maximum number of labels, attachments and comments
  // that we might need.
  get csvHeaderRow () {
    return _.concat([
      "Issue Key",
      "Issue Id",
      "Parent Id",
      "Summary",
      "Issue Type",
      "Assignee",
      "Reporter",
      "Description",
      "Status",
      "Date Created",
      "Date Modified",
      "Resolution",
       ],
       _.fill(Array(this.maxLabels),'Label'),
       _.fill(Array(this.maxAttachments),'Attachment'),
       _.fill(Array(this.maxComments),'Comment'),
    );
  }

  // As input expect an item that has already been transformed,
  // with comments and attachments added
  // Return an array.
  transformItemToArray (item) {
    // Pad any empty columns
    let padLabels, padComments, padAttachments;

    try {
      padLabels = Array(this.maxLabels-item.labels.length);
      padComments = Array(this.maxComments-item.comments.length);
      padAttachments = Array(this.maxAttachments-item.attachments.length);
    }
    catch (e) {
      console.error("Arrayifying row %s failed. Row content was %j",
         this.numItemsArrayified+1, item);
      throw new Error(e);
    }

      this.numItemsArrayified++;

    return _.concat([
      item['Issue Key'],
      item['Issue Id'],
      item['Parent Id'],
      item['Summary'],
      item['Issue Type'],
      item['Assignee'],
      item['Reporter'],
      item['Description'],
      item['Status'],
      item['Date Created'],
      item['Date Modified'],
      item['Resolution'],
      ],
      item.labels, padLabels,
      item.attachments, padAttachments,
      item.comments, padComments,
    )

  }

  // Given an array of extracted items with comments and attachments added,
  // convert them into an an array of arrays ready to write out to a CSV
  transformAllItemsToCSVArray (items) {
    return _.concat(
      [ this.csvHeaderRow ],
      items.map(item => {
        const jiraIssue = this.transformItem(item)
        return this.transformItemToArray(jiraIssue);
      }),
    );

  }

  // Given an array of arrays "rows", convert it to a CSV string and write it to disk
  // at this.csvFileName
  async writeCSVFile(rows) {
    return fs.writeFileSync(this.csvFileName, await stringify(rows));
  }

  // The main do-it-all function
  async exportSprintlyToJiraCSV () {
    console.log(`STARTing export from Sprint.ly ${this.sprintlyProjectNum} for JIRA ${this.jiraProjectKey}`);

    // Creates this.ticketParentMap for use in parent/child mapping
    console.log("1/6. Starting to extract parent/child ticket mappings.");
    await this.extractItemParentIds();

    console.log("2/6. Starting extractAllItems");
    const items = await this.extractAllItems();

    console.log("3/6. Adding all comments. (slow)");
    await this.addCommentsToAllItems(items);

    console.log("4/6. Adding all attachments. (slow)");
    await this.addAttachmentsToAllItems(items);

    console.log("5/6. Transforming data to in-memory Array of Arrays");
    const csvArray = this.transformAllItemsToCSVArray(items);

    console.log("6/6. Transforming to in-memory CSV String and writing to disk at "+this.csvFileName);
    this.writeCSVFile(csvArray);

    console.log("DONE.");

  }

} // end Sprintly2Jira Class


module.exports = SprintlyToJira
